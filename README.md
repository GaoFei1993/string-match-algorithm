# 字符串搜索算法（string-match-algorithm）

问题：有一个文本串S和一个模式串P，现在要查找P在S中的位置，怎么查找呢？  
算法：（1）暴力匹配算法（2）KMP算法（3）BM算法（4）Sunday算法，上述算法性能排名为从低到高。  
其中，BM算法还没有调试！  

# 1、暴力搜索
假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：
* 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；
* 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。
KMP的整体时间复杂度为O(n^2)。

# 2、KMP算法（Next[]）
假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：  
* 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；  
* 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。  
此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。  
KMP的整体时间复杂度为O(m + n)。  

# 3、BM算法（全称为Boyer-Moore算法）
该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。  
BM算法最坏情况下O(N)的时间复杂度。BM算法则往往比KMP算法快上3－5倍。  

# 4、Sunday算法（跟BM算法很相似）  
Sunday算法是从前往后匹配，在匹配失败时关注的是文本串S中参加匹配的最末位字符的下一位字符。  
* 如果该字符没有在模式串P中出现，则直接移动整个模式串P，其移动位数 = 匹配串长度 + 1；  
* 否则寻找该字符在模式串P中最右端的位置，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。  
* 移动模式串P后，对比模式串P和文本串S的第一个元素，重新开始从前往后匹配，一旦失配，则按步骤（1）和（2）来。  

# 字符串查找算法性能排名：
Sunday算法 > BM算法 > KMP算法 > 库函数strstr()（暴力搜索）  
BM算法则往往比KMP算法快上3－5倍。  
